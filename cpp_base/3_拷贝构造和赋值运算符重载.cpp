/**
 * date: 2020/02/15
 * 
 * 类的[拷贝构造和赋值运算符重载]
 * 
 * [补充]：浅拷贝与深拷贝区别
 * “浅拷贝只复制指向某个对象的指针，而不复制对象本身，
 * 新旧对象还是共享同一块内存。
 * 
 * 但深拷贝会另外创造一个一模一样的对象，
 * 新对象跟原对象不共享内存，修改新对象不会改到原对象。”
 * 
 * 
 * 1. 拷贝构造函数:
 * class 类名{
 *      类名(const 类名& another);
 * };
 * 1. 系统提供默认的拷贝构造(等位拷贝，也叫浅拷贝)，若自己提供，则不复存在。
 * 2. 默认拷贝构造是等位拷贝
 * 3. 要实现深拷贝，必须要自己实现
 * 
 * 2. 赋值运算符重载:
 * class 类名{
 *  类名& operator = (const 类名&源对象){
 *      ...;
 *      return *this;  // 返回this指针
 *  }
 * };
 * 
 * [问题}
 * 拷贝构造(浅拷贝):有可能造成内存泄漏，重析构
 * 
 * 拷贝构造中：
 *      例如: other对象的指针值直接赋给对象a, 
 *      那么两个对象的该指针成员变量则同时指向一个内存地址。
 *      当对象a和对象other分别析构时，会两次释放同一内存
 * 
 * 赋值运算符重载中：
 *      例如：other对象和a对象的指针都各自有指向堆内存的一段空间。
 *      若直接把other中的指针值赋给对象a，那么就造成了对象a中指针值原本指向的堆内存空间泄露
 * 
 * 
 * 
*/
#include<iostream>
#include<string>

class A{
public:
    A(int n = 0): num(n) {}

    /**
     * 拷贝[构造函数]:等位拷贝(是啥拷贝啥)
     * a 对象还没创建，other对象已经存在
     * 
     */ 
    A(const A& other):num(other.num) {}

    /**
     * 赋值运算符重载
     * a对象已经创建，other对象也已经创建
     * 和拷贝构造区别： 两个对象均已创建结束后，发生的赋值行为
     * 
     */ 
    A& operator= (const A& other){
        num = other.num;
        return *this;
    }
private:
    int num;
};

int main(){
    std::string s1("abc");  // 直接初始化
    std::string s2("1234");
    std::string s3(s2);   // 直接初始化(调用拷贝构造函数)
    std::string s4 = s2;  // 拷贝初始化
    std::string s5;
    s5 = s2;  // 赋值操作
    A a1;
    A a2(a1);  // 直接初始化(调用拷贝构造函数)
    A a3 = a1;  // 拷贝初始化
    const A a4;
    A a5 = a4;  // 参数无const, 报错
    A a6;
    a6 = a1;  //赋值（调用赋值运算符重载）
    return 0;
}